{"version":3,"sources":["../src/packageLogs.ts","../src/attachHandlers.ts","../src/utils/auth/index.ts","../src/utils/headers/index.ts","../src/getInitialSettings.ts","../src/configure.ts","../src/sendLogs.ts","../src/main.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Callbacks, Logging } from \"@/types\";\nimport { Configuration } from \"@/configure\";\n\nexport let logs: Array<Logging.Log>;\nlet config: Configuration;\n\n// Interval Logging Globals\nlet intervalId: string | null;\nlet intervalType: string | null;\nlet intervalPath: string[] | null;\nlet intervalTimer: number | null;\nlet intervalCounter: number | null;\nlet intervalLog: Logging.Log | null;\n\nexport const filterHandler: CallableFunction | null = null;\nexport const mapHandler: CallableFunction | null = null;\nexport let cbHandlers: Callbacks.CallbackMap = {};\n\n/**\n * Adds named callbacks to be executed when logging.\n * @param  {Object } newCallbacks An object containing named callback functions.\n */\nexport function addCallbacks(\n  ...newCallbacks: Record<symbol | string, CallableFunction>[]\n) {\n  newCallbacks.forEach((source) => {\n    let descriptors: { [key in string | symbol]: any } = {};\n\n    descriptors = Object.keys(source).reduce((descriptors, key) => {\n      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);\n      return descriptors;\n    }, descriptors);\n\n    Object.getOwnPropertySymbols(source).forEach((sym) => {\n      const descriptor = Object.getOwnPropertyDescriptor(source, sym);\n      if (descriptor?.enumerable) {\n        descriptors[sym] = descriptor;\n      }\n    });\n    Object.defineProperties(cbHandlers, descriptors);\n  });\n  return cbHandlers;\n}\n\n/**\n * Removes callbacks by name.\n * @param  {String[]} targetKeys A list of names of functions to remove.\n */\nexport function removeCallbacks(targetKeys: string[]) {\n  targetKeys.forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(cbHandlers, key)) {\n      delete cbHandlers[key];\n    }\n  });\n}\n\n/**\n * Assigns the config and log container to be used by the logging functions.\n * @param  {Array<Logging.Log>} newLogs   Log container.\n * @param  {Object} newConfig Configuration to use while logging.\n */\nexport function initPackager(\n  newLogs: Array<Logging.Log>,\n  newConfig: Configuration,\n) {\n  logs = newLogs;\n  config = newConfig;\n  cbHandlers = {};\n  intervalId = null;\n  intervalType = null;\n  intervalPath = null;\n  intervalTimer = null;\n  intervalCounter = 0;\n  intervalLog = null;\n}\n\n/**\n * Transforms the provided HTML event into a log and appends it to the log queue.\n * @param  {Event} e         The event to be logged.\n * @param  {Function} detailFcn The function to extract additional log parameters from the event.\n * @return {boolean}           Whether the event was logged.\n */\nexport function packageLog(\n  e: Event,\n  detailFcn?: Logging.DynamicDetailFunction | null,\n) {\n  if (!config.on) {\n    return false;\n  }\n\n  let details = null;\n  if (detailFcn) {\n    details = detailFcn(e);\n  }\n\n  const timeFields = extractTimeFields(\n    e.timeStamp && e.timeStamp > 0 ? config.time(e.timeStamp) : Date.now(),\n  );\n\n  let log: Logging.Log = {\n    target: e.target ? getSelector(e.target) : null,\n    path: buildPath(e),\n    pageUrl: self.location.href,\n    pageTitle: document.title,\n    pageReferrer: document.referrer,\n    userAgent: self.navigator.userAgent,\n    clientTime: timeFields.milli,\n    microTime: timeFields.micro,\n    location: getLocation(e),\n    scrnRes: getScreenRes(),\n    type: e.type,\n    logType: \"raw\",\n    userAction: true,\n    details: details,\n    userId: config.userId,\n    toolVersion: config.toolVersion,\n    toolName: config.toolName,\n    useraleVersion: config.useraleVersion,\n    sessionId: config.sessionId,\n    httpSessionId: config.httpSessionId,\n    browserSessionId: config.browserSessionId,\n    attributes: buildAttrs(e),\n    style: buildCSS(e),\n  };\n\n  if (typeof filterHandler === \"function\" && !filterHandler(log)) {\n    return false;\n  }\n\n  if (typeof mapHandler === \"function\") {\n    log = mapHandler(log, e);\n  }\n\n  for (const func of Object.values(cbHandlers)) {\n    if (typeof func === \"function\") {\n      log = func(log, e);\n      if (!log) {\n        return false;\n      }\n    }\n  }\n\n  logs.push(log);\n  return true;\n}\n\n/**\n * Packages the provided customLog to include standard meta data and appends it to the log queue.\n * @param  {Logging.CustomLog} customLog        The behavior to be logged.\n * @param  {Logging.DynamicDetailFunction} detailFcn     The function to extract additional log parameters from the event.\n * @param  {boolean} userAction     Indicates user behavior (true) or system behavior (false)\n * @return {boolean}           Whether the event was logged.\n */\nexport function packageCustomLog(\n  customLog: Logging.CustomLog,\n  detailFcn: Logging.DynamicDetailFunction | Logging.StaticDetailFunction,\n  userAction: boolean,\n): boolean {\n  if (!config.on) {\n    return false;\n  }\n\n  let details = null;\n  if (detailFcn.length === 0) {\n    // In the case of a union, the type checker will default to the more stringent\n    // type, i.e. the DetailFunction that expects an argument for safety purposes.\n    // To avoid this, we must explicitly check the type by asserting it receives\n    // no arguments (detailFcn.length === 0) and then cast it to the\n    // StaticDetailFunction type.\n    const staticDetailFcn = detailFcn as Logging.StaticDetailFunction;\n    details = staticDetailFcn();\n  }\n\n  const metaData = {\n    pageUrl: self.location.href,\n    pageTitle: document.title,\n    pageReferrer: document.referrer,\n    userAgent: self.navigator.userAgent,\n    clientTime: Date.now(),\n    scrnRes: getScreenRes(),\n    logType: \"custom\",\n    userAction: userAction,\n    details: details,\n    userId: config.userId,\n    toolVersion: config.toolVersion,\n    toolName: config.toolName,\n    useraleVersion: config.useraleVersion,\n    sessionId: config.sessionId,\n    httpSessionId: config.httpSessionId,\n    browserSessionId: config.browserSessionId,\n  };\n\n  let log = Object.assign(metaData, customLog);\n\n  if (typeof filterHandler === \"function\" && !filterHandler(log)) {\n    return false;\n  }\n\n  if (typeof mapHandler === \"function\") {\n    log = mapHandler(log);\n  }\n\n  for (const func of Object.values(cbHandlers)) {\n    if (typeof func === \"function\") {\n      log = func(log, null);\n      if (!log) {\n        return false;\n      }\n    }\n  }\n\n  logs.push(log);\n\n  return true;\n}\n\n/**\n * Extract the millisecond and microsecond portions of a timestamp.\n * @param  {Number} timeStamp The timestamp to split into millisecond and microsecond fields.\n * @return {Object}           An object containing the millisecond\n *                            and microsecond portions of the timestamp.\n */\nexport function extractTimeFields(timeStamp: number) {\n  return {\n    milli: Math.floor(timeStamp),\n    micro: Number((timeStamp % 1).toFixed(3)),\n  };\n}\n\n/**\n * Track intervals and gather details about it.\n * @param {Object} e\n * @return boolean\n */\nexport function packageIntervalLog(e: Event) {\n  try {\n    const target = e.target ? getSelector(e.target) : null;\n    const path = buildPath(e);\n    const type = e.type;\n    const timestamp = Math.floor(\n      e.timeStamp && e.timeStamp > 0 ? config.time(e.timeStamp) : Date.now(),\n    );\n\n    // Init - this should only happen once on initialization\n    if (intervalId == null) {\n      intervalId = target;\n      intervalType = type;\n      intervalPath = path;\n      intervalTimer = timestamp;\n      intervalCounter = 0;\n    }\n\n    if ((intervalId !== target || intervalType !== type) && intervalTimer) {\n      // When to create log? On transition end\n      // @todo Possible for intervalLog to not be pushed in the event the interval never ends...\n\n      intervalLog = {\n        target: intervalId,\n        path: intervalPath,\n        pageUrl: self.location.href,\n        pageTitle: document.title,\n        pageReferrer: document.referrer,\n        userAgent: self.navigator.userAgent,\n        count: intervalCounter,\n        duration: timestamp - intervalTimer, // microseconds\n        startTime: intervalTimer,\n        endTime: timestamp,\n        type: intervalType,\n        logType: \"interval\",\n        targetChange: intervalId !== target,\n        typeChange: intervalType !== type,\n        userAction: false,\n        userId: config.userId,\n        toolVersion: config.toolVersion,\n        toolName: config.toolName,\n        useraleVersion: config.useraleVersion,\n        sessionId: config.sessionId,\n        httpSessionId: config.httpSessionId,\n        browserSessionId: config.browserSessionId,\n      };\n\n      if (typeof filterHandler === \"function\" && !filterHandler(intervalLog)) {\n        return false;\n      }\n\n      if (typeof mapHandler === \"function\") {\n        intervalLog = mapHandler(intervalLog, e);\n      }\n\n      for (const func of Object.values(cbHandlers)) {\n        if (typeof func === \"function\") {\n          intervalLog = func(intervalLog, null);\n          if (!intervalLog) {\n            return false;\n          }\n        }\n      }\n\n      if (intervalLog) logs.push(intervalLog);\n\n      // Reset\n      intervalId = target;\n      intervalType = type;\n      intervalPath = path;\n      intervalTimer = timestamp;\n      intervalCounter = 0;\n    }\n\n    // Interval is still occuring, just update counter\n    if (intervalId == target && intervalType == type && intervalCounter) {\n      intervalCounter = intervalCounter + 1;\n    }\n\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extracts coordinate information from the event\n * depending on a few browser quirks.\n * @param  {Event} e The event to extract coordinate information from.\n * @return {Object}   An object containing nullable x and y coordinates for the event.\n */\nexport function getLocation(e: Event) {\n  if (e instanceof MouseEvent) {\n    if (e.pageX != null) {\n      return { x: e.pageX, y: e.pageY };\n    } else if (e.clientX != null) {\n      return {\n        x: document.documentElement.scrollLeft + e.clientX,\n        y: document.documentElement.scrollTop + e.clientY,\n      };\n    }\n  } else {\n    return { x: null, y: null };\n  }\n}\n\n/**\n * Extracts innerWidth and innerHeight to provide estimates of screen resolution\n * @return {Object} An object containing the innerWidth and InnerHeight\n */\nexport function getScreenRes() {\n  return { width: self.innerWidth, height: self.innerHeight };\n}\n\n/**\n * Builds a string CSS selector from the provided element\n * @param  {EventTarget} ele The element from which the selector is built.\n * @return {string}     The CSS selector for the element, or Unknown if it can't be determined.\n */\nexport function getSelector(ele: EventTarget) {\n  if (ele instanceof HTMLElement || ele instanceof Element) {\n    if (ele.localName) {\n      return (\n        ele.localName +\n        (ele.id ? \"#\" + ele.id : \"\") +\n        (ele.className ? \".\" + ele.className : \"\")\n      );\n    } else if (ele.nodeName) {\n      return (\n        ele.nodeName +\n        (ele.id ? \"#\" + ele.id : \"\") +\n        (ele.className ? \".\" + ele.className : \"\")\n      );\n    }\n  } else if (ele instanceof Document) {\n    return \"#document\";\n  } else if (ele === globalThis) {\n    return \"Window\";\n  }\n  return \"Unknown\";\n}\n\n/**\n * Builds an array of elements from the provided event target, to the root element.\n * @param  {Event} e Event from which the path should be built.\n * @return {HTMLElement[]}   Array of elements, starting at the event target, ending at the root element.\n */\nexport function buildPath(e: Event) {\n  const path = e.composedPath();\n  return selectorizePath(path);\n}\n\n/**\n * Builds a CSS selector path from the provided list of elements.\n * @param  {EventTarget[]} path Array of HTML Elements from which the path should be built.\n * @return {string[]}      Array of string CSS selectors.\n */\nexport function selectorizePath(path: EventTarget[]) {\n  let i = 0;\n  let pathEle;\n  const pathSelectors: string[] = [];\n  while ((pathEle = path[i])) {\n    pathSelectors.push(getSelector(pathEle));\n    ++i;\n    pathEle = path[i];\n  }\n  return pathSelectors;\n}\n\n/**\n * Builds an object containing attributes of an element.\n * Attempts to parse all attribute values as JSON text.\n * @param  {Event} e Event from which the target element's attributes should be extracted.\n * @return {Record<string, any>} Object with element attributes as key-value pairs.\n */\nexport function buildAttrs(e: Event): Record<string, any> {\n  const attributes: Record<string, any> = {};\n  const attributeBlackList = [\"style\"];\n\n  if (e.target && e.target instanceof Element) {\n    for (const attr of e.target.attributes) {\n      if (attributeBlackList.includes(attr.name)) continue;\n      let val: any = attr.value;\n      try {\n        val = JSON.parse(val);\n      } catch {\n        // Ignore parsing errors, fallback to raw string value\n      }\n      attributes[attr.name] = val;\n    }\n  }\n\n  return attributes;\n}\n\n/**\n * Builds an object containing all CSS properties of an element.\n * @param  {Event} e Event from which the target element's properties should be extracted.\n * @return {Record<string, string>} Object with all CSS properties as key-value pairs.\n */\nexport function buildCSS(e: Event): Record<string, string> {\n  const properties: Record<string, string> = {};\n  if (e.target && e.target instanceof HTMLElement) {\n    const styleObj = e.target.style;\n    for (let i = 0; i < styleObj.length; i++) {\n      const prop = styleObj[i];\n      properties[prop] = styleObj.getPropertyValue(prop);\n    }\n  }\n  return properties;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { packageLog, packageIntervalLog } from \"@/packageLogs\";\nimport { Events, Logging, Settings } from \"@/types\";\nimport { Configuration } from \"@/configure\";\n\n//@todo: Investigate drag events and their behavior\nlet events: Events.EventDetailsMap<Events.AllowedEvents>;\nlet bufferBools: Events.EventBoolMap<Events.BufferedEvents>;\nlet bufferedEvents: Events.EventDetailsMap<Events.BufferedEvents>;\nlet refreshEvents: Events.EventDetailsMap<Events.RefreshEvents>;\nconst intervalEvents: Array<Events.IntervalEvents> = [\n  \"click\",\n  \"focus\",\n  \"blur\",\n  \"input\",\n  \"change\",\n  \"mouseover\",\n  \"submit\",\n];\nconst windowEvents: Array<Events.WindowEvents> = [\"load\", \"blur\", \"focus\"];\n\n/**\n * Maps a MouseEvent to an object containing useful information.\n * @param  {MouseEvent} e Event to extract data from\n */\nexport function extractMouseDetails(e: MouseEvent) {\n  return {\n    clicks: e.detail,\n    ctrl: e.ctrlKey,\n    alt: e.altKey,\n    shift: e.shiftKey,\n    meta: e.metaKey,\n    //    'text' : e.target.innerHTML\n  };\n}\n\n/** Maps a KeyboardEvent to an object containing useful infromation\n * @param {KeyboardEvent} e Event to extract data from\n */\nexport function extractKeyboardDetails(e: KeyboardEvent) {\n  return {\n    key: e.key,\n    code: e.code,\n    ctrl: e.ctrlKey,\n    alt: e.altKey,\n    shift: e.shiftKey,\n    meta: e.metaKey,\n  };\n}\n\n/**\n * Maps an InputEvent to an object containing useful information.\n * @param  {InputEvent} e Event to extract data from\n */\nexport function extractInputDetails(e: InputEvent) {\n  return {\n    value: (e.target as HTMLInputElement).value,\n  };\n}\n\n/**\n * Maps a ChangeEvent to an object containing useful information.\n * @param  {Events.ChangeEvent} e Event to extract data from\n */\nexport function extractChangeDetails(e: Events.ChangeEvent) {\n  return {\n    value: e.target.value,\n  };\n}\n\n/**\n * Maps a WheelEvent to an object containing useful information.\n * @param  {WheelEvent} e Event to extract data from\n */\nexport function extractWheelDetails(e: WheelEvent) {\n  return {\n    x: e.deltaX,\n    y: e.deltaY,\n    z: e.deltaZ,\n  };\n}\n\n/**\n * Maps a ScrollEvent to an object containing useful information.\n */\nexport function extractScrollDetails() {\n  return {\n    x: window.scrollX,\n    y: window.scrollY,\n  };\n}\n\n/**\n * Maps a ResizeEvent to an object containing useful information.\n */\nexport function extractResizeDetails() {\n  return {\n    width: window.outerWidth,\n    height: window.outerHeight,\n  };\n}\n\n/**\n * Defines the way information is extracted from various events.\n * Also defines which events we will listen to.\n * @param  {Settings.Config} config Configuration object to read from.\n */\nexport function defineDetails(config: Settings.DefaultConfig): void {\n  // Events list\n  // Keys are event types\n  // Values are functions that return details object if applicable\n  events = {\n    click: extractMouseDetails,\n    dblclick: extractMouseDetails,\n    mousedown: extractMouseDetails,\n    mouseup: extractMouseDetails,\n    focus: null,\n    blur: null,\n    input: config.logDetails ? extractKeyboardDetails : null,\n    change: config.logDetails ? extractChangeDetails : null,\n    dragstart: null,\n    dragend: null,\n    drag: null,\n    drop: null,\n    keydown: config.logDetails ? extractKeyboardDetails : null,\n    mouseover: null,\n  };\n\n  bufferBools = {};\n  bufferedEvents = {\n    wheel: extractWheelDetails,\n    scroll: extractScrollDetails,\n    resize: extractResizeDetails,\n  };\n\n  refreshEvents = {\n    submit: null,\n  };\n}\n\n/**\n * Defines the way information is extracted from various events.\n * Also defines which events we will listen to.\n * @param  {Settings.Config} options UserALE Configuration object to read from.\n * @param   {Events.AllowedEvents}    type of html event (e.g., 'click', 'mouseover', etc.), such as passed to addEventListener methods.\n */\nexport function defineCustomDetails(\n  options: Settings.DefaultConfig,\n  type: Events.AllowedEvents,\n): Logging.DynamicDetailFunction | null | undefined {\n  // Events list\n  // Keys are event types\n  // Values are functions that return details object if applicable\n  const eventType: Events.EventDetailsMap<Events.AllowedEvents> = {\n    click: extractMouseDetails,\n    dblclick: extractMouseDetails,\n    mousedown: extractMouseDetails,\n    mouseup: extractMouseDetails,\n    focus: null,\n    blur: null,\n    load: null,\n    input: options.logDetails ? extractKeyboardDetails : null,\n    change: options.logDetails ? extractChangeDetails : null,\n    dragstart: null,\n    dragend: null,\n    drag: null,\n    drop: null,\n    keydown: options.logDetails ? extractKeyboardDetails : null,\n    mouseover: null,\n    wheel: extractWheelDetails,\n    scroll: extractScrollDetails,\n    resize: extractResizeDetails,\n    submit: null,\n  };\n  return eventType[type];\n}\n\n/**\n * Hooks the event handlers for each event type of interest.\n * @param  {Configuration} config Configuration singleton to use.\n * @return {boolean}        Whether the operation succeeded\n */\nexport function attachHandlers(config: Configuration): boolean {\n  try {\n    defineDetails(config);\n\n    (Object.keys(events) as Events.AllowedEvents[]).forEach(function (ev) {\n      document.addEventListener(\n        ev,\n        function (e) {\n          packageLog(e, events[ev]);\n        },\n        true,\n      );\n    });\n\n    intervalEvents.forEach(function (ev) {\n      document.addEventListener(\n        ev,\n        function (e) {\n          packageIntervalLog(e);\n        },\n        true,\n      );\n    });\n\n    (Object.keys(bufferedEvents) as Events.BufferedEvents[]).forEach(\n      function (ev) {\n        bufferBools[ev] = true;\n\n        self.addEventListener(\n          ev,\n          function (e) {\n            if (bufferBools[ev]) {\n              bufferBools[ev] = false;\n              packageLog(e, bufferedEvents[ev]);\n              setTimeout(function () {\n                bufferBools[ev] = true;\n              }, config.resolution);\n            }\n          },\n          true,\n        );\n      },\n    );\n\n    (Object.keys(refreshEvents) as Events.RefreshEvents[]).forEach(\n      function (ev) {\n        document.addEventListener(\n          ev,\n          function (e) {\n            packageLog(e, events[ev]);\n          },\n          true,\n        );\n      },\n    );\n\n    windowEvents.forEach(function (ev) {\n      self.addEventListener(\n        ev,\n        function (e) {\n          packageLog(e, function () {\n            return { window: true };\n          });\n        },\n        true,\n      );\n    });\n\n    return true;\n  } catch {\n    return false;\n  }\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Configuration } from \"@/configure\";\nimport { Callbacks } from \"@/types\";\n\nexport let authCallback: Callbacks.AuthCallback | null = null;\n\n/**\n * Fetches the most up-to-date auth header string from the auth callback\n * and updates the config object with the new value.\n * @param {Configuration} config Configuration object to be updated.\n * @param {Function} authCallback Callback used to fetch the newest header.\n * @returns {void}\n */\nexport function updateAuthHeader(config: Configuration) {\n  if (authCallback) {\n    try {\n      config.authHeader = authCallback();\n    } catch (e) {\n      // We should emit the error, but otherwise continue as this could be a temporary issue\n      // due to network connectivity or some logic inside the authCallback which is the user's\n      // responsibility.\n      console.error(`Error encountered while setting the auth header: ${e}`);\n    }\n  }\n}\n\n/**\n * Registers the provided callback to be used when updating the auth header.\n * @param {Callbacks.AuthCallback} callback Callback used to fetch the newest header. Should return a string.\n * @returns {boolean} Whether the operation succeeded.\n */\nexport function registerAuthCallback(callback: Callbacks.AuthCallback) {\n  try {\n    verifyCallback(callback);\n    authCallback = callback;\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Verify that the provided callback is a function which returns a string\n * @param {Function} callback Callback used to fetch the newest header. Should return a string.\n * @throws {Error} If the callback is not a function or does not return a string.\n * @returns {void}\n */\nexport function verifyCallback(callback: Callbacks.AuthCallback) {\n  if (typeof callback !== \"function\") {\n    throw new Error(\"Userale auth callback must be a function\");\n  }\n  const result = callback();\n  if (typeof result !== \"string\") {\n    throw new Error(\"Userale auth callback must return a string\");\n  }\n}\n\n/**\n * Resets the authCallback to null. Used for primarily for testing, but could be used\n * to remove the callback in production.\n * @returns {void}\n */\nexport function resetAuthCallback() {\n  authCallback = null;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Configuration } from \"@/configure\";\nimport { Callbacks } from \"@/types\";\n\nexport let headersCallback: Callbacks.HeadersCallback | null = null;\n\n/**\n * Fetches the most up-to-date custom headers object from the headers callback\n * and updates the config object with the new value.\n * @param {Configuration} config Configuration object to be updated.\n * @param {Callbacks.HeadersCallback} headersCallback Callback used to fetch the newest headers.\n * @returns {void}\n */\nexport function updateCustomHeaders(config: Configuration) {\n  if (headersCallback) {\n    try {\n      config.headers = headersCallback();\n    } catch (e) {\n      // We should emit the error, but otherwise continue as this could be a temporary issue\n      // due to network connectivity or some logic inside the headersCallback which is the user's\n      // responsibility.\n      console.error(`Error encountered while setting the headers: ${e}`);\n    }\n  }\n}\n\n/**\n * Registers the provided callback to be used when updating the auth header.\n * @param {Callbacks.HeadersCallback} callback Callback used to fetch the newest headers. Should return an object.\n * @returns {boolean} Whether the operation succeeded.\n */\nexport function registerHeadersCallback(callback: Callbacks.HeadersCallback) {\n  try {\n    verifyCallback(callback);\n    headersCallback = callback;\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Verify that the provided callback is a function which returns a string\n * @param {Callbacks.HeadersCallback} callback Callback used to fetch the newest header. Should return an object.\n * @throws {Error} If the callback is not a function or does not return a string.\n * @returns {void}\n */\nexport function verifyCallback(callback: Callbacks.HeadersCallback) {\n  if (typeof callback !== \"function\") {\n    throw new Error(\"Userale headers callback must be a function\");\n  }\n  const result = callback();\n  if (typeof result !== \"object\") {\n    throw new Error(\"Userale headers callback must return an object\");\n  }\n  for (const [key, value] of Object.entries(result)) {\n    if (typeof key !== \"string\" || typeof value !== \"string\") {\n      throw new Error(\n        \"Userale header callback must return an object with string keys and values\",\n      );\n    }\n  }\n}\n\n/**\n * Resets the authCallback to null. Used for primarily for testing, but could be used\n * to remove the callback in production.\n * @returns {void}\n */\nexport function resetHeadersCallback() {\n  headersCallback = null;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the 'License'); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Settings } from \"./types\";\n\nlet sessionId: string | null = null;\nlet httpSessionId: string | null = null;\n\n/**\n * Extracts the initial configuration settings from the\n * currently executing script tag.\n * @return {Object} The extracted configuration object\n */\nexport function getInitialSettings(): Settings.Config {\n  if (\n    typeof WorkerGlobalScope !== \"undefined\" &&\n    self instanceof WorkerGlobalScope\n  ) {\n    const settings: Settings.Config = {\n      authHeader: null,\n      autostart: true,\n      browserSessionId: null,\n      custIndex: null,\n      headers: null,\n      httpSessionId: null,\n      logCountThreshold: +5,\n      logDetails: false,\n      resolution: +500,\n      sessionId: sessionId,\n      time: (ts?: number) => (ts !== undefined ? ts : Date.now()),\n      toolName: null,\n      toolVersion: null,\n      transmitInterval: +5000,\n      url: \"http://localhost:8000\",\n      useraleVersion: null,\n      userFromParams: null,\n      userId: null,\n    };\n    return settings;\n  }\n\n  if (sessionId === null) {\n    sessionId = getsessionId(\n      \"userAlesessionId\",\n      \"session_\" + String(Date.now()),\n    );\n  }\n\n  if (httpSessionId === null) {\n    httpSessionId = getsessionId(\n      \"userAleHttpSessionId\",\n      generatehttpSessionId(),\n    );\n  }\n\n  const script =\n    document.currentScript ||\n    (function () {\n      const scripts = document.getElementsByTagName(\"script\");\n      return scripts[scripts.length - 1];\n    })();\n\n  const get = script\n    ? script.getAttribute.bind(script)\n    : function () {\n        return null;\n      };\n  const headers = get(\"data-headers\");\n  const settings: Settings.Config = {\n    authHeader: get(\"data-auth\") || null,\n    autostart: get(\"data-autostart\") === \"false\" ? false : true,\n    browserSessionId: null,\n    custIndex: get(\"data-index\") || null,\n    headers: headers ? JSON.parse(headers) : null,\n    httpSessionId: httpSessionId,\n    logCountThreshold: +(get(\"data-threshold\") || 5),\n    logDetails: get(\"data-log-details\") === \"true\" ? true : false,\n    resolution: +(get(\"data-resolution\") || 500),\n    sessionId: get(\"data-session\") || sessionId,\n    time: timeStampScale(document.createEvent(\"CustomEvent\")),\n    toolName: get(\"data-tool\") || null,\n    toolVersion: get(\"data-version\") || null,\n    transmitInterval: +(get(\"data-interval\") || 5000),\n    url: get(\"data-url\") || \"http://localhost:8000\",\n    useraleVersion: get(\"data-userale-version\") || null,\n    userFromParams: get(\"data-user-from-params\") || null,\n    userId: get(\"data-user\") || null,\n  };\n  return settings;\n}\n\n/**\n * defines sessionId, stores it in sessionStorage, checks to see if there is a sessionId in\n * storage when script is started. This prevents events like 'submit', which refresh page data\n * from refreshing the current user session\n *\n */\nexport function getsessionId(sessionKey: string, value: any) {\n  if (self.sessionStorage.getItem(sessionKey) === null) {\n    self.sessionStorage.setItem(sessionKey, JSON.stringify(value));\n    return value;\n  }\n\n  return JSON.parse(self.sessionStorage.getItem(sessionKey) || \"\");\n}\n\n/**\n * Creates a function to normalize the timestamp of the provided event.\n * @param  {Event} e An event containing a timeStamp property.\n * @return {typeof timeStampScale~tsScaler}   The timestamp normalizing function.\n */\nexport function timeStampScale(e: Event): Settings.TimeFunction {\n  let tsScaler: Settings.TimeFunction;\n  if (e.timeStamp && e.timeStamp > 0) {\n    const delta = Date.now() - e.timeStamp;\n    /**\n     * Returns a timestamp depending on various browser quirks.\n     * @param  {?Number} ts A timestamp to use for normalization.\n     * @return {Number} A normalized timestamp.\n     */\n\n    if (delta < 0) {\n      tsScaler = function () {\n        return e.timeStamp / 1000;\n      };\n    } else if (delta > e.timeStamp) {\n      const navStart = performance.timeOrigin;\n      tsScaler = function (ts) {\n        return ts + navStart;\n      };\n    } else {\n      tsScaler = function (ts) {\n        return ts;\n      };\n    }\n  } else {\n    tsScaler = function () {\n      return Date.now();\n    };\n  }\n\n  return tsScaler;\n}\n\n/**\n * Creates a cryptographiclly random string to represent this http session.\n * @return {String}   A random 32 digit hex string\n */\nfunction generatehttpSessionId(): string {\n  // 32 digit hex -> 128 bits of info -> 2^64 ~= 10^19 sessions needed for 50% chance of collison\n  const len = 32;\n  const arr = new Uint8Array(len / 2);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, (dec) => {\n    return dec.toString(16).padStart(2, \"0\");\n  }).join(\"\");\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInitialSettings } from \"@/getInitialSettings\";\nimport type { Settings } from \"@/types\";\n\n// Singleton Configuration class\nexport class Configuration {\n  [key: string]: Settings.ConfigValueTypes;\n  // Private static property to hold the singleton instance\n  private static instance: Configuration | null = null;\n\n  // Public properties corresponding to fields in the Config interface\n  public autostart: boolean = false;\n  public authHeader: Settings.AuthHeader = null;\n  public browserSessionId: Settings.SessionId = null;\n  public custIndex: Settings.CustomIndex = null;\n  public headers: Settings.Headers = null;\n  public httpSessionId: Settings.SessionId = null;\n  public logCountThreshold: number = 0;\n  public logDetails: boolean = false;\n  public on: boolean = false;\n  public resolution: number = 0;\n  public sessionId: Settings.SessionId = null;\n  public time: Settings.TimeFunction = () => Date.now();\n  public toolName: Settings.ToolName = null;\n  public toolVersion: Settings.Version = null;\n  public transmitInterval: number = 0;\n  public url: string = \"\";\n  public userFromParams: Settings.UserFromParams = null;\n  public useraleVersion: Settings.Version = null;\n  public userId: Settings.UserId = null;\n  public version: Settings.Version = null;\n  public websocketsEnabled: boolean = false;\n\n  // Private constructor to prevent external instantiation\n  private constructor() {\n    // Call the initialization method only if it's the first time instantiating\n    if (Configuration.instance === null) {\n      this.initialize();\n    }\n  }\n\n  // Static method to get the singleton instance\n  public static getInstance(): Configuration {\n    if (Configuration.instance === null) {\n      Configuration.instance = new Configuration();\n    }\n    return Configuration.instance;\n  }\n\n  private initialize(): void {\n    const settings = getInitialSettings();\n    this.update(settings);\n  }\n\n  /**\n   * Resets the configuration to its initial state.\n   */\n  public reset(): void {\n    this.initialize();\n  }\n\n  /**\n   * Shallow merges a newConfig with the configuration class, updating it.\n   * Retrieves/updates the userid if userFromParams is provided.\n   * @param  {Partial<Settings.Config>} newConfig Configuration object to merge into the current config.\n   */\n  public update(newConfig: Partial<Settings.Config>): void {\n    Object.keys(newConfig).forEach((option) => {\n      if (option === \"userFromParams\") {\n        const userParamString = newConfig[option] as Settings.UserFromParams;\n        const userId = userParamString\n          ? Configuration.getUserIdFromParams(userParamString)\n          : null;\n        if (userId) {\n          this[\"userId\"] = userId;\n        }\n      }\n      const hasNewUserFromParams = newConfig[\"userFromParams\"];\n      const willNullifyUserId =\n        option === \"userId\" && newConfig[option] === null;\n      if (willNullifyUserId && hasNewUserFromParams) {\n        return;\n      }\n\n      const newOption = newConfig[option];\n      if (newOption !== undefined) {\n        this[option] = newOption;\n      }\n    });\n  }\n\n  /**\n   * Attempts to extract the userid from the query parameters of the URL.\n   * @param  {string} param The name of the query parameter containing the userid.\n   * @return {string | null}       The extracted/decoded userid, or null if none is found.\n   */\n  public static getUserIdFromParams(param: string) {\n    const userField = param;\n    const regex = new RegExp(\"[?&]\" + userField + \"(=([^&#]*)|&|#|$)\");\n    const results = window.location.href.match(regex);\n\n    if (results && results[2]) {\n      return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n    }\n    return null;\n  }\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Configuration } from \"@/configure\";\nimport { Logging } from \"@/types\";\nimport { updateAuthHeader, updateCustomHeaders } from \"@/utils\";\n\nlet sendIntervalId: string | number | NodeJS.Timeout | undefined;\nlet wsock: WebSocket;\n\n/**\n * Initializes the log queue processors.\n * @param  {Array<Logging.Log>} logs   Array of logs to append to.\n * @param  {Configuration} config Configuration object to use when logging.\n */\nexport function initSender(logs: Array<Logging.Log>, config: Configuration) {\n  if (sendIntervalId) {\n    clearInterval(sendIntervalId);\n  }\n\n  const url = new URL(config.url);\n  if (url.protocol === \"ws:\" || url.protocol === \"wss:\") {\n    wsock = new WebSocket(config.url);\n  }\n\n  sendIntervalId = sendOnInterval(logs, config);\n  sendOnClose(logs, config);\n}\n\n/**\n * Checks the provided log array on an interval, flushing the logs\n * if the queue has reached the threshold specified by the provided config.\n * @param  {Array<Logging.Log>} logs   Array of logs to read from.\n * @param  {Configuration} config Configuration singleton to be read from.\n * @return {Number}        The newly created interval id.\n */\nexport function sendOnInterval(\n  logs: Array<Logging.Log>,\n  config: Configuration,\n): NodeJS.Timeout {\n  return setInterval(function () {\n    if (!config.on) {\n      return;\n    }\n\n    if (logs.length >= config.logCountThreshold) {\n      sendLogs(logs.slice(0), config, 0); // Send a copy\n      logs.splice(0); // Clear array reference (no reassignment)\n    }\n  }, config.transmitInterval);\n}\n\n// /**\n//  * Attempts to flush the remaining logs when the window is closed.\n//  * @param  {Array<Logging.Log>} logs   Array of logs to be flushed.\n//  * @param  {Configuration} config Configuration singleton to be read from.\n//  */\nexport function sendOnClose(\n  logs: Array<Logging.Log>,\n  config: Configuration,\n): void {\n  self.addEventListener(\"pagehide\", function () {\n    if (!config.on) {\n      return;\n    }\n\n    if (logs.length > 0) {\n      const url = new URL(config.url);\n\n      if (url.protocol === \"ws:\" || url.protocol === \"wss:\") {\n        const data = JSON.stringify(logs);\n        wsock.send(data);\n      } else {\n        const headers: HeadersInit = new Headers();\n        headers.set(\"Content-Type\", \"application/json;charset=UTF-8\");\n\n        if (config.authHeader) {\n          headers.set(\"Authorization\", config.authHeader.toString());\n        }\n\n        fetch(config.url, {\n          keepalive: true,\n          method: \"POST\",\n          headers: headers,\n          body: JSON.stringify(logs),\n        }).catch((error) => {\n          console.error(error);\n        });\n      }\n      logs.splice(0); // clear log queue\n    }\n  });\n}\n\n/**\n * Sends the provided array of logs to the specified url,\n * retrying the request up to the specified number of retries.\n * @param  {Array<Logging.Log>} logs    Array of logs to send.\n * @param  {Configuration} config     configuration singleton.\n * @param  {Number} retries Maximum number of attempts to send the logs.\n */\nexport async function sendLogs(\n  logs: Array<Logging.Log>,\n  config: Configuration,\n  retries: number,\n): Promise<void> {\n  const data = JSON.stringify(logs);\n  const url = new URL(config.url);\n\n  if (url.protocol === \"ws:\" || url.protocol === \"wss:\") {\n    wsock.send(data);\n    return;\n  }\n\n  // Build headers\n  const headers = new Headers({\n    \"Content-Type\": \"application/json;charset=UTF-8\",\n  });\n\n  updateAuthHeader(config);\n  if (config.authHeader) {\n    const authHeaderValue =\n      typeof config.authHeader === \"function\"\n        ? config.authHeader()\n        : config.authHeader;\n    headers.set(\"Authorization\", authHeaderValue);\n  }\n\n  // Update custom headers last to allow them to over-write the defaults. This assumes\n  // the user knows what they are doing and may want to over-write the defaults.\n  updateCustomHeaders(config);\n  if (config.headers) {\n    for (const [header, value] of Object.entries(config.headers)) {\n      headers.set(header, value);\n    }\n  }\n\n  async function attemptSend(remainingRetries: number): Promise<void> {\n    try {\n      const response = await fetch(config.url, {\n        method: \"POST\",\n        headers,\n        body: data,\n      });\n\n      if (!response.ok) {\n        if (remainingRetries > 0) {\n          return attemptSend(remainingRetries - 1);\n        } else {\n          throw new Error(`Failed to send logs: ${response.statusText}`);\n        }\n      }\n    } catch (error) {\n      if (remainingRetries > 0) {\n        return attemptSend(remainingRetries - 1);\n      }\n      throw error;\n    }\n  }\n\n  return attemptSend(retries);\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { defineCustomDetails } from \"@/attachHandlers\";\nimport { registerAuthCallback } from \"@/utils\";\nimport {\n  addCallbacks,\n  removeCallbacks,\n  packageLog,\n  packageCustomLog,\n  getSelector,\n  buildPath,\n  initPackager,\n} from \"@/packageLogs\";\nimport { version as userAleVersion } from \"../package.json\";\nimport { Configuration } from \"@/configure\";\nimport { attachHandlers } from \"@/attachHandlers\";\nimport { initSender } from \"@/sendLogs\";\n\nimport type { Settings, Logging } from \"@/types\";\n\nconst config = Configuration.getInstance();\nconst logs: Array<Logging.Log> = [];\n\nconst startLoadTimestamp = Date.now();\nlet endLoadTimestamp: number;\nself.onload = function () {\n  endLoadTimestamp = Date.now();\n};\n\nexport let started = false;\nexport { defineCustomDetails as details } from \"@/attachHandlers\";\nexport { registerAuthCallback as registerAuthCallback } from \"@/utils\";\nexport {\n  addCallbacks as addCallbacks,\n  removeCallbacks as removeCallbacks,\n  packageLog as packageLog,\n  packageCustomLog as packageCustomLog,\n  getSelector as getSelector,\n  buildPath as buildPath,\n} from \"@/packageLogs\";\nexport type { Logging } from \"@/types\";\n\nconfig.update({\n  useraleVersion: userAleVersion,\n});\ninitPackager(logs, config);\nif (config.autostart) {\n  setup(config);\n}\n\n/**\n * Hooks the global event listener, and starts up the\n * logging interval.\n * @param  {Configuration} config Configuration settings for the logger\n */\nfunction setup(config: Configuration) {\n  if (!started) {\n    setTimeout(function () {\n      let state;\n      try {\n        state = document.readyState;\n      } catch (error) {\n        // Assume there is no DOM and this is a web worker context\n        state = \"complete\";\n      }\n\n      if (\n        config.autostart &&\n        (state === \"interactive\" || state === \"complete\")\n      ) {\n        attachHandlers(config);\n        initSender(logs, config);\n        started = config.on = true;\n        if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n          packageCustomLog(\n            {\n              type: \"load\",\n              details: { pageLoadTime: endLoadTimestamp - startLoadTimestamp },\n            },\n            () => ({}),\n            false,\n          );\n        }\n      } else {\n        setup(config);\n      }\n    }, 100);\n  }\n}\n\n// Export the Userale API\nexport const version = userAleVersion;\n\n/**\n * Used to start the logging process if the\n * autostart configuration option is set to false.\n */\nexport function start(): void {\n  if (!started || config.autostart === false) {\n    started = config.on = true;\n    config.update({ autostart: true });\n  }\n}\n\n/**\n * Halts the logging process. Logs will no longer be sent.\n */\nexport function stop(): void {\n  started = config.on = false;\n  config.update({ autostart: false });\n}\n\n/**\n * Updates the current configuration\n * object with the provided values.\n * @param  {Partial<Settings.Config>} newConfig The configuration options to use.\n * @return {Settings.Config}           Returns the updated configuration.\n */\nexport function options(\n  newConfig: Partial<Settings.Config> | undefined,\n): Settings.Config {\n  if (newConfig) {\n    config.update(newConfig);\n  }\n\n  return config;\n}\n\n/**\n * Appends a log to the log queue.\n * @param  {Logging.CustomLog} customLog The log to append.\n * @return {boolean}          Whether the operation succeeded.\n */\nexport function log(customLog: Logging.CustomLog | undefined) {\n  if (customLog) {\n    logs.push(customLog);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// Only attach to window in IIFE builds\nif (typeof window !== \"undefined\") {\n  (window as any).userale = {\n    start,\n    stop,\n    options,\n    log,\n    version: userAleVersion,\n    details: defineCustomDetails,\n    registerAuthCallback,\n    addCallbacks,\n    removeCallbacks,\n    packageLog,\n    packageCustomLog,\n    getSelector,\n    buildPath,\n  };\n}\n"],"mappings":"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","names":["descriptors","log","config","options","config","config","settings","logs","config","config","logs","version"]}